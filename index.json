[{"content":"Delegates Overview In Unreal Engine, delegates are a way to call a function indirectly. Instead of one class directly invoking another, a delegate works as a signal that other functions can subscribe to. When the delegate is triggered, all the subscribed functions are executed.\nDelegates are similar to function pointers or events in other programming languages. They are often used to respond to actions such as button clicks, gameplay events, or data changes.\nUnreal Engine provides four types of delegates:\nBasic \u0026ndash; Single-listener | C++ only Multicast \u0026ndash; Multi-listerner | C++ Only Dynamic \u0026ndash; Single-listener | Blueprint support Dynamic Multicast \u0026ndash; Multi-listerner | Blueprint support Each type is suited for a different scenario, depending on whether you need one or many listeners, and whether Blueprint exposure is required.\nGetting Started with Delegates In order to create our first delegate, we’ll need to use the DECLARE_DELEGATE(DelegateName) macro. Delegate declarations should be placed in a header file that also includes its corresponding generated header which ends with .generated.h.\nWhen a header contains a UENUM, USTRUCT, or UCLASS, the Unreal Header Tool (UHT) automatically generates a *.generated.h file, with the prefix matching the header’s filename. For example, if the header is MyHeader.h, UHT will create MyHeader.generated.h.\nIf your header doesn’t already include a UENUM, USTRUCT, or UCLASS, you can add a dummy one to force UHT to create the generated header file. Keep in mind that the *.generated.h include must always be the last include in your header file.\nLet’s assume we don’t already have a suitable header file in our project. In that case, the first step is to create a brand-new header file named MyHeader.h, which will be dedicated to declaring your delegate.\nExample: MyHeader.h #pragma once #include \u0026#34;CoreMinimal.h\u0026#34; #include \u0026#34;MyHeader.generated.h\u0026#34; // Dummy UENUM to ensure .generated.h file is created UENUM() enum class EMyDummyEnum : uint8 { Value1 }; Now that our header is ready, we can declare the delegate by adding this line:\nDECLARE_DELEGATE(FMyDelegate); Example: MyHeader.h #pragma once #include \u0026#34;CoreMinimal.h\u0026#34; #include \u0026#34;MyHeader.generated.h\u0026#34; // Delegate declaration DECLARE_DELEGATE(FMyDelegate); // Dummy UENUM to ensure .generated.h file is created UENUM() enum class EMyDummyEnum : uint8 { Value1 }; After declaring a delegate type, the next steps are creating an instance, binding a function, and executing it.\nExample: MySource.cpp #include \u0026#34;MyHeader.h\u0026#34; class FMyClass { public: void OnEventTriggered() { UE_LOG(LogTemp, Warning, TEXT(\u0026#34;Delegate called!\u0026#34;)); } }; void TestDelegate() { FMyDelegate MyDelegate; FMyClass MyObject; // Bind member function MyDelegate.BindRaw(\u0026amp;MyObject, \u0026amp;FMyClass::) // Execute delegate if (MyDelegate.IsBound()) { MyDelegate.Execute(); // Calls OnEventTriggered } // Safer alternative MyDelegate.ExecuteIfBound(); } Well, let\u0026rsquo;s start using our delegate.\nFMyDelegate MyDelegate; Now, it can be bound and executed. There are several functions for binding basic delegates that each of them is used for a specific type of targets:\nBindStatic BindLambda BindSPLambda BindWeakLambda BindRaw BindSP BindThreadSafeSP BindUFunction BindUObject Let\u0026rsquo;s see how every one of them could be used:\nBindStatic : Can be used to bind global functions and static member functions. It can also bind lambdas which don\u0026rsquo;t have any captures because they are treated as a function pointer.\nvoid TargetFunc() { UE_LOG(LogTemp, Warning, TEXT(\u0026#34;ReceiverFunction called\u0026#34;)); } class Foo { public: static void StaticTargetFunc(); }; void Foo::StaticTargetFunc() { UE_LOG(LogTemp, Warning, TEXT(\u0026#34;StaticReceiverFunction called\u0026#34;)); } void TestDelegate() { FOnMyEventOccured OnMyEventOccured; // Binding a global function OnMyEventOccured.BindStatic(\u0026amp;TargetFunc); if (OnMyEventOccured.IsBound()) OnMyEventOccured.Execute(); // Calls ReceiverFunction // Binding a static member function OnMyEventOccured.BindStatic(\u0026amp;Foo::StaticTargetFunc); if (OnMyEventOccured.IsBound()) OnMyEventOccured.Execute(); // Calls Foo::StaticReceiverFunction // Binding a captureless lambda OnMyEventOccured.BindStatic([](){ UE_LOG(LogTemp, Warning, TEXT(\u0026#34;Lambda called\u0026#34;)); }); if (OnMyEventOccured.IsBound()) OnMyEventOccured.Execute(); // Calls the lambda // // The one below won\u0026#39;t compile because of the capture: // // int C; // OnMyEventOccured.BindStatic([C](){}); // } BindLambda : This one can bind a lambda, or technically every functor type incluing global functions, static member functions, and every object that implements operator().\nBindSPLambda :\nBindWeakLambda :\nBindRaw :\nBindSP :\nBindThreadSafeSP :\nBindUFunction :\nBindUObject :\nMulticast Delegate Dynamic Delegate Dynamic Multicast Delegate ","permalink":"https://ali-askari-dev.github.io/posts/post1/","summary":"Understand the different types of delegates in Unreal Engine and when to use each one","title":"Mastering Delegates in Unreal Engine"}]