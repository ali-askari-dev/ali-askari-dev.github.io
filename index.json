[{"content":"Delegates Overview In Unreal Engine, delegates are a way to call a function indirectly. Instead of one class directly invoking another, a delegate works as a signal that other functions can subscribe to. When the delegate is triggered, all the subscribed functions are executed.\nDelegates are similar to function pointers or events in other programming languages. They are often used to respond to actions such as button clicks, gameplay events, or data changes.\nUnreal Engine provides four types of delegates:\nBasic \u0026ndash; Single-listener | C++ only Multicast \u0026ndash; Multi-listerner | C++ Only Dynamic \u0026ndash; Single-listener | Blueprint support Dynamic Multicast \u0026ndash; Multi-listerner | Blueprint support Each type is suited for a different scenario, depending on whether you need one or many listeners, and whether Blueprint exposure is required.\nGetting Started with Delegates In order to create our first delegate, we’ll need to use the DECLARE_DELEGATE(DelegateName) macro. Delegate declarations should be placed in a header file that also includes its corresponding generated header which ends with .generated.h.\nWhen a header contains a UENUM, USTRUCT, or UCLASS, the Unreal Header Tool (UHT) automatically generates a *.generated.h file, with the prefix matching the header’s filename. For example, if the header is MyHeader.h, UHT will create MyHeader.generated.h.\nIf your header doesn’t already include a UENUM, USTRUCT, or UCLASS, you can add a dummy one to force UHT to create the generated header file. Keep in mind that the *.generated.h include must always be the last include in your header file.\nLet’s assume we don’t already have a suitable header file in our project. In that case, the first step is to create a brand-new header file named MyHeader.h, which will be dedicated to declaring our delegate.\nExample: MyHeader.h #pragma once #include \u0026#34;CoreMinimal.h\u0026#34; #include \u0026#34;MyHeader.generated.h\u0026#34; // Dummy UENUM to ensure .generated.h file is created UENUM() enum class EMyDummyEnum : uint8 { Value1 }; Now that our header is ready, we can declare the delegate by adding this line:\nDECLARE_DELEGATE(FMyDelegate); Example: MyHeader.h #pragma once #include \u0026#34;CoreMinimal.h\u0026#34; #include \u0026#34;MyHeader.generated.h\u0026#34; // Delegate declaration DECLARE_DELEGATE(FMyDelegate); // Dummy UENUM to ensure .generated.h file is created UENUM() enum class EMyDummyEnum : uint8 { Value1 }; Once the delegate has been declared in the header, the next step is to actually put it into action. To make use of a delegate, we need to create an instance of it, connect it to a function, and then trigger that function through the delegate.\nIn the following example, you’ll see how to set up an instance of the delegate we just declared, bind it to a member function of a class, and then execute it. This will demonstrate the typical workflow you’ll follow whenever you want to use delegates in your own project.\nExample: MySource.cpp #include \u0026#34;MyHeader.h\u0026#34; class FMyClass { public: void OnEventTriggered() { UE_LOG(LogTemp, Warning, TEXT(\u0026#34;Delegate called!\u0026#34;)); } }; void TestDelegate() { FMyDelegate MyDelegate; FMyClass MyObject; // Bind member function MyDelegate.BindRaw(\u0026amp;MyObject, \u0026amp;FMyClass::OnEventTriggered) // Execute delegate if (MyDelegate.IsBound()) { MyDelegate.Execute(); // Calls OnEventTriggered } // Safer alternative MyDelegate.ExecuteIfBound(); } Binding Delegates There are several functions for binding basic delegates that each of them is used for a specific type of targets:\nBindStatic BindLambda BindSPLambda BindWeakLambda BindRaw BindSP BindThreadSafeSP BindUFunction BindUObject Let\u0026rsquo;s see how every one of them could be used:\nBindStatic : Can be used to bind global functions and static member functions. It can also bind lambdas which don\u0026rsquo;t have any captures because in C++ they are treated as a function pointer.\nvoid OnEventTriggerd() { UE_LOG(LogTemp, Warning, TEXT(\u0026#34;Delegate called\u0026#34;)); } class Foo { public: static void OnEventTriggered(); }; void Foo::OnEventTriggered() { UE_LOG(LogTemp, Warning, TEXT(\u0026#34;Delegate called\u0026#34;)); } void TestDelegate() { FMyDelegate MyDelegate; // Binding a global function MyDelegate.BindStatic(\u0026amp;OnEventTriggered); if (MyDelegate.IsBound()) MyDelegate.Execute(); // Calls OnEventTriggered // Binding a static member function MyDelegate.BindStatic(\u0026amp;Foo::OnEventTriggered); if (MyDelegate.IsBound()) MyDelegate.Execute(); // Calls Foo::OnEventTriggered // Binding a captureless lambda MyDelegate.BindStatic([](){ UE_LOG(LogTemp, Warning, TEXT(\u0026#34;Lambda called\u0026#34;)); }); if (MyDelegate.IsBound()) MyDelegate.Execute(); // Calls the lambda // // The one below won\u0026#39;t compile because of the capture: // // int C; // MyDelegate.BindStatic([C](){}); // } BindLambda : This one can bind a lambda, or technically every functor type incluing global functions, static member functions, and every object that implements operator().\nBindSPLambda :\nBindWeakLambda :\nBindRaw :\nBindSP :\nBindThreadSafeSP :\nBindUFunction :\nBindUObject :\nMulticast Delegate Dynamic Delegate Dynamic Multicast Delegate ","permalink":"https://ali-askari-dev.github.io/posts/post1/","summary":"Understand the different types of delegates in Unreal Engine and when to use each one","title":"Mastering Delegates in Unreal Engine"}]